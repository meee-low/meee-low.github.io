var m=Object.defineProperty;var d=(r,t,e)=>t in r?m(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var c=(r,t,e)=>d(r,typeof t!="symbol"?t+"":t,e);class a{constructor(t,e,s=0){c(this,"rows");c(this,"cols");c(this,"_impl");this.rows=t,this.cols=e,this._impl=Array(t*e).fill(s)}at(t,e){return this._impl[t*this.cols+e]}set(t,e,s){return this._impl[t*this.cols+e]=s,this}applyToCell(t,e,s){return this.set(t,e,s(this.at(t,e))),this}applyToAll(t){for(let e=0;e<this._impl.length;++e)this._impl[e]=t(this._impl[e]);return this}copy(){let t=new a(this.rows,this.cols);return t._impl=[...this._impl],t}shape(){return[this.rows,this.cols]}toArrayOfArrays(){let t=[];for(let e=0;e<this.rows;++e){t.push([]);for(let s=0;s<this.cols;++s)t[e].push(this.at(e,s))}return t}matMult(t,e=void 0){if(t.cols!==this.rows)throw new Error(`ValueError: Incompatible matrix dimensions. Left matrix has ${this.rows} rows but right matrix has ${t.cols} columns.`);if(e){if(e.rows!==this.rows||e.cols!==t.cols)throw new Error("ValueError: The result matrix has incompatible dimensions.")}else e=new a(this.rows,t.cols);for(let s=0;s<this.rows;++s)for(let o=0;o<t.cols;++o){let n=0;for(let l=0;l<this.cols;++l)n+=this.at(s,l)*t.at(l,o);e.set(s,o,n)}return e}static identity(t){const e=new a(t,t,0);for(let s=0;s<t;++s)for(let o=0;o<t;++o)s===o&&e.set(s,o,1);return e}scale(t){return this.applyToAll(e=>e*t)}static fromArray(t,e){if(t.length!==e[0]*e[1])throw new Error("ValueError: Incompatible dimensions.");const s=new a(e[0],e[1]);return s._impl=t,s}static fromArrayOfArrays(t){let e=new a(t.length,t[0].length);for(let s=0;s<t.length;++s){if(t[s].length!==t[0].length)throw new Error(`ValueError: row #${s} of this array has an invalid length. Expected ${t[0].length}, found ${t[s].length}.`);for(let o=0;o<t[s].length;++o)e.set(s,o,t[s][o])}return e}static rot2D(t){return a.fromArray([Math.cos(t),-Math.sin(t),Math.sin(t),Math.cos(t)],[2,2])}static rot2DDegrees(t){const s=t*.01745329251;return a.rot2D(s)}getRow(t){const e=t*this.cols;return this._impl.slice(e,e+this.cols)}getCol(t){let e=[];for(let s=0;s<this.rows;++s)e.push(this.at(s,t));return e}transpose(){if(this.rows!==this.cols)throw new Error("Needs to be a square matrix to transpose.");for(let t=0;t<this.cols;++t)for(let e=t+1;e<this.rows;++e)this.swap(t,e,e,t);return this}swap(t,e,s,o){const n=this.at(t,e),l=this.at(s,o);this.set(t,e,l),this.set(s,o,n)}transformVec2(t){if(this.cols!==2||this.rows!==2)throw new Error("Incompatible matrix size. Need a 2x2 matrix to operate on Vec2's.");const e=t.x*this.at(0,0)+t.y*this.at(0,1),s=t.x*this.at(1,0)+t.y*this.at(1,1);return t.x=e,t.y=s,t}}function g(r){let e=new Array(r.rows).fill(1);for(let s=0;s<10;++s){e=C(r,e);const o=y(e);for(let n=0;n<e.length;++n)e[n]/=o}return e}function y(r){return Math.pow(r.reduce((t,e)=>t*e,1),1/r.length)}function E(r,t,e){const s=t[e];let o=0,n=0;for(let i=0;i<t.length;++i){if(i===e)continue;const h=t[i];o+=r.at(e,i)*h/(s+h),n+=r.at(i,e)/(s+h)}const l=1;return(o+l)/(n+l)}function C(r,t){for(let e=0;e<t.length;++e)t[e]=E(r,t,e);return t}function T(r){let t=[];for(let e=0;e<r.rows;++e){const s=r.getRow(e).reduce((n,l)=>n+l,0)+1,o=r.getCol(e).reduce((n,l)=>n+l,0)+1;t.push(s/(s+o))}return t}class A{constructor(t){c(this,"elements");c(this,"comparisons");if(t.length<=1)throw new Error("Must have at least 2 elements to start ranking.");if(new Set(t).size!==t.length)throw new Error("Elements should all be distinct.");this.elements=[...t],this.comparisons=new a(this.elements.length,this.elements.length)}evaluate(t){return t(this.comparisons)}sortedElements(t){const e=this.evaluate(t);return this.elements.map((s,o)=>[s,e[o]]).sort(([,s],[,o])=>o-s).map(([s])=>s)}addComparison(t,e){const s=this.elements.indexOf(t),o=this.elements.indexOf(e);if(s<0||o<0)throw new Error("This pair was not found in the ranker.");this.comparisons.applyToCell(s,o,n=>n+1)}suggestComparison(t=p.random){const e=t(this.comparisons);let s={};e.forEach((h,w)=>{s[h]||(s[h]=[]),s[h].push(w)});const o=Object.keys(s).map(Number).sort((h,w)=>h-w),n=s[o[0]];let l=-1,i=-1;if(n.length>=2)[l,i]=f(n.length);else{l=n[u(n.length)];const h=s[o[1]];i=h[u(h.length)]}return console.assert(l>=0),console.assert(i>=0),console.assert(l!==i),Math.random()<.5?[this.elements[l],this.elements[i]]:[this.elements[i],this.elements[l]]}getTotalComparisons(){let t=0;for(let e=0;e<this.comparisons.rows;e++)for(let s=0;s<this.comparisons.cols;s++)t+=this.comparisons.at(e,s);return t}}class I extends A{constructor(e){super(e);c(this,"currentlyCompared");const s=f(e.length);this.currentlyCompared=[this.elements[s[0]],this.elements[s[1]]]}newComparison(e=p.random){return this.currentlyCompared=this.suggestComparison(e),this.currentlyCompared}handleWinner(e){this.addComparison(this.currentlyCompared[e],this.currentlyCompared[(e+1)%2])}}function u(r){return Math.floor(Math.random()*r)}function f(r){if(r<2)throw new Error(`Need at least 2, got ${r}.`);const t=u(r),e=u(r-1)+1,s=(t+e)%r;return console.assert(0<=t),console.assert(0<=s),console.assert(t<r),console.assert(s<r),console.assert(t!==s),[t,s]}function b(r){throw new Error("Not implemented")}const N={elo:b,winrate:T,bradleyTerry:g};function j(r){let t=Array(r.rows).fill(0);for(let e=0;e<r.rows;++e)for(let s=0;s<r.cols;++s)t[e]+=r.at(e,s),t[s]+=r.at(e,s);return t}const p={random:r=>{let t=new Array(r.rows,0);for(let e=0;e<r.rows;++e)t[e]=Math.random();return t},fewestComparisonsFirst:j};export{p as M,I as P,A as R,N as e};
