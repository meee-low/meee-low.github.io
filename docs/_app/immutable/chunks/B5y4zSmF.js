var m=Object.defineProperty;var d=(r,t,s)=>t in r?m(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var c=(r,t,s)=>d(r,typeof t!="symbol"?t+"":t,s);class a{constructor(t,s,e=0){c(this,"rows");c(this,"cols");c(this,"_impl");this.rows=t,this.cols=s,this._impl=Array(t*s).fill(e)}at(t,s){return this._impl[t*this.cols+s]}set(t,s,e){return this._impl[t*this.cols+s]=e,this}applyToCell(t,s,e){return this.set(t,s,e(this.at(t,s))),this}applyToAll(t){for(let s=0;s<this._impl.length;++s)this._impl[s]=t(this._impl[s]);return this}copy(){let t=new a(this.rows,this.cols);return t._impl=[...this._impl],t}shape(){return[this.rows,this.cols]}toArrayOfArrays(){let t=[];for(let s=0;s<this.rows;++s){t.push([]);for(let e=0;e<this.cols;++e)t[s].push(this.at(s,e))}return t}matMult(t,s=void 0){if(t.cols!==this.rows)throw new Error(`ValueError: Incompatible matrix dimensions. Left matrix has ${this.rows} rows but right matrix has ${t.cols} columns.`);if(s){if(s.rows!==this.rows||s.cols!==t.cols)throw new Error("ValueError: The result matrix has incompatible dimensions.")}else s=new a(this.rows,t.cols);for(let e=0;e<this.rows;++e)for(let o=0;o<t.cols;++o){let n=0;for(let l=0;l<this.cols;++l)n+=this.at(e,l)*t.at(l,o);s.set(e,o,n)}return s}static identity(t){const s=new a(t,t,0);for(let e=0;e<t;++e)for(let o=0;o<t;++o)e===o&&s.set(e,o,1);return s}scale(t){return this.applyToAll(s=>s*t)}static fromArray(t,s){if(t.length!==s[0]*s[1])throw new Error("ValueError: Incompatible dimensions.");const e=new a(s[0],s[1]);return e._impl=t,e}static fromArrayOfArrays(t){let s=new a(t.length,t[0].length);for(let e=0;e<t.length;++e){if(t[e].length!==t[0].length)throw new Error(`ValueError: row #${e} of this array has an invalid length. Expected ${t[0].length}, found ${t[e].length}.`);for(let o=0;o<t[e].length;++o)s.set(e,o,t[e][o])}return s}static rot2D(t){return a.fromArray([Math.cos(t),-Math.sin(t),Math.sin(t),Math.cos(t)],[2,2])}static rot2DDegrees(t){const e=t*.01745329251;return a.rot2D(e)}getRow(t){const s=t*this.cols;return this._impl.slice(s,s+this.cols)}getCol(t){let s=[];for(let e=0;e<this.rows;++e)s.push(this.at(e,t));return s}transpose(){if(this.rows!==this.cols)throw new Error("Needs to be a square matrix to transpose.");for(let t=0;t<this.cols;++t)for(let s=t+1;s<this.rows;++s)this.swap(t,s,s,t);return this}swap(t,s,e,o){const n=this.at(t,s),l=this.at(e,o);this.set(t,s,l),this.set(e,o,n)}transformVec2(t){if(this.cols!==2||this.rows!==2)throw new Error("Incompatible matrix size. Need a 2x2 matrix to operate on Vec2's.");const s=t.x*this.at(0,0)+t.y*this.at(0,1),e=t.x*this.at(1,0)+t.y*this.at(1,1);return t.x=s,t.y=e,t}}function g(r){let s=new Array(r.rows).fill(1);for(let e=0;e<10;++e){s=C(r,s);const o=y(s);for(let n=0;n<s.length;++n)s[n]/=o}return s}function y(r){return Math.pow(r.reduce((t,s)=>t*s,1),1/r.length)}function E(r,t,s){const e=t[s];let o=0,n=0;for(let h=0;h<t.length;++h){if(h===s)continue;const i=t[h];o+=r.at(s,h)*i/(e+i),n+=r.at(h,s)/(e+i)}const l=1;return(o+l)/(n+l)}function C(r,t){for(let s=0;s<t.length;++s)t[s]=E(r,t,s);return t}class T{constructor(t){c(this,"elements");c(this,"comparisons");if(t.length<=1)throw new Error("Must have at least 2 elements to start ranking.");if(new Set(t).size!==t.length)throw new Error("Elements should all be distinct.");this.elements=[...t],this.comparisons=new a(this.elements.length,this.elements.length)}evaluate(t){return t(this.comparisons)}sortedElements(t){const s=this.evaluate(t);return this.elements.map((e,o)=>[e,s[o]]).sort(([,e],[,o])=>o-e).map(([e])=>e)}addComparison(t,s){const e=this.elements.indexOf(t),o=this.elements.indexOf(s);if(e<0||o<0)throw new Error("This pair was not found in the ranker.");this.comparisons.applyToCell(e,o,n=>n+1)}suggestComparison(t=p.random){const s=t(this.comparisons);let e={};s.forEach((i,w)=>{e[i]||(e[i]=[]),e[i].push(w)});const o=Object.keys(e).map(Number).sort((i,w)=>i-w),n=e[o[0]];let l=-1,h=-1;if(n.length>=2)[l,h]=f(n.length).map(i=>n[i]);else{l=n[u(n.length)];const i=e[o[1]];h=i[u(i.length)]}return console.assert(l>=0),console.assert(h>=0),console.assert(l!==h),Math.random()<.5?[this.elements[l],this.elements[h]]:[this.elements[h],this.elements[l]]}getTotalComparisons(){let t=0;for(let s=0;s<this.comparisons.rows;s++)for(let e=0;e<this.comparisons.cols;e++)t+=this.comparisons.at(s,e);return t}}class j extends T{constructor(s){super(s);c(this,"currentlyCompared");const e=f(s.length);this.currentlyCompared=[this.elements[e[0]],this.elements[e[1]]]}newComparison(s=p.random){return this.currentlyCompared=this.suggestComparison(s),this.currentlyCompared}handleWinner(s){this.addComparison(this.currentlyCompared[s],this.currentlyCompared[(s+1)%2])}}function u(r){return Math.floor(Math.random()*r)}function f(r){if(r<2)throw new Error(`Need at least 2, got ${r}.`);const t=u(r),s=u(r-1)+1,e=(t+s)%r;return console.assert(0<=t),console.assert(0<=e),console.assert(t<r),console.assert(e<r),console.assert(t!==e),[t,e]}const I={bradleyTerry:g};function A(r){let t=Array(r.rows).fill(0);for(let s=0;s<r.rows;++s)for(let e=0;e<r.cols;++e)t[s]+=r.at(s,e),t[e]+=r.at(s,e);return t}const p={random:r=>{let t=new Array(r.rows,0);for(let s=0;s<r.rows;++s)t[s]=Math.random();return t},fewestComparisonsFirst:A};export{p as M,j as P,T as R,I as e};
